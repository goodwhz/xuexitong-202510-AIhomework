# 论文搜索引擎部署指南

## 部署概述

本指南将详细介绍如何部署论文搜索引擎系统，包括本地开发环境搭建、生产环境部署和Netlify在线部署。

## 环境要求

### 系统要求
- **操作系统**: Windows 10+, macOS 10.15+, Ubuntu 18.04+
- **Python**: 3.8+
- **Node.js**: 16+ (用于前端构建)
- **内存**: 至少8GB RAM (推荐16GB)
- **存储**: 至少20GB可用空间
- **GPU**: 可选，用于加速LLM推理

### 软件依赖
- Python 3.8+
- pip (Python包管理器)
- Git
- Docker (可选)
- Redis (可选，用于缓存)

## 本地开发环境部署

### 1. 环境准备

#### 克隆项目
```bash
git clone <repository-url>
cd 论文搜索引擎网站
```

#### 创建虚拟环境
```bash
# Windows
python -m venv venv
venv\Scripts\activate

# Linux/macOS
python -m venv venv
source venv/bin/activate
```

#### 安装Python依赖
```bash
pip install -r requirements.txt
```

### 2. 配置环境变量

创建 `.env` 文件：
```bash
# 后端配置
HOST=0.0.0.0
PORT=8000
DEBUG=True

# 数据库配置
VECTOR_DB_PATH=./data/chroma
REDIS_URL=redis://localhost:6379

# LLM配置
LLM_MODEL_PATH=./models/qwen
LLM_API_KEY=your-api-key

# ArXiv配置
ARXIV_API_URL=http://export.arxiv.org/api/query
```

### 3. 初始化数据

#### 创建必要目录
```bash
mkdir -p data/chroma
mkdir -p logs
mkdir -p models
```

#### 下载Qwen模型 (可选)
```bash
# 如果使用本地Qwen模型
python scripts/download_model.py --model qwen/Qwen-7B-Chat
```

### 4. 启动服务

#### 启动后端服务
```bash
cd backend
python main.py
```

#### 启动前端服务
```bash
cd frontend
python -m http.server 3000
```

#### 访问应用
- 前端: http://localhost:3000
- 后端API: http://localhost:8000
- API文档: http://localhost:8000/docs

## 生产环境部署

### 1. Docker部署

#### 创建Dockerfile
```dockerfile
# backend/Dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 创建docker-compose.yml
```yaml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - HOST=0.0.0.0
      - PORT=8000
      - DEBUG=False
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - redis
      - vector-db

  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  vector-db:
    image: chromadb/chroma:latest
    ports:
      - "8001:8000"
    volumes:
      - vector_data:/chroma/chroma

volumes:
  redis_data:
  vector_data:
```

#### 启动服务
```bash
docker-compose up -d
```

### 2. 传统服务器部署

#### 安装系统依赖
```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y python3.9 python3.9-venv python3-pip nginx redis-server

# CentOS/RHEL
sudo yum install -y python39 python39-pip nginx redis
```

#### 配置Nginx
```nginx
# /etc/nginx/sites-available/paper-search
server {
    listen 80;
    server_name your-domain.com;

    # 前端静态文件
    location / {
        root /var/www/paper-search/frontend;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    # 后端API代理
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### 配置systemd服务
```ini
# /etc/systemd/system/paper-search.service
[Unit]
Description=Paper Search Engine API
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/var/www/paper-search/backend
ExecStart=/var/www/paper-search/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

#### 启动服务
```bash
sudo systemctl enable paper-search
sudo systemctl start paper-search
sudo systemctl enable nginx
sudo systemctl start nginx
```

## Netlify部署

### 1. 准备部署文件

#### 创建netlify.toml
```toml
[build]
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "18"

[[redirects]]
  from = "/api/*"
  to = "https://your-backend-api.herokuapp.com/api/:splat"
  status = 200

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
    X-Content-Type-Options = "nosniff"
```

#### 修改前端配置
```javascript
// frontend/static/js/config.js
const config = {
  apiBaseUrl: process.env.NODE_ENV === 'production' 
    ? 'https://your-backend-api.herokuapp.com/api'
    : 'http://localhost:8000/api',
  
  llmApiKey: process.env.VITE_LLM_API_KEY,
  
  features: {
    enableLocalLLM: false,
    enableVectorSearch: true,
    enableCaching: true
  }
};

export default config;
```

### 2. 构建前端

#### 安装构建依赖
```bash
cd frontend
npm init -y
npm install --save-dev @babel/core @babel/preset-env
npm install --save-dev webpack webpack-cli
npm install --save-dev html-webpack-plugin
```

#### 创建webpack配置
```javascript
// frontend/webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './static/js/app.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
      filename: 'index.html'
    })
  ],
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
};
```

#### 构建脚本
```json
// frontend/package.json
{
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch"
  }
}
```

### 3. 部署到Netlify

#### 方法1: 通过Git部署
1. 将代码推送到GitHub仓库
2. 在Netlify中连接GitHub仓库
3. 配置构建设置：
   - Build command: `cd frontend && npm run build`
   - Publish directory: `frontend/dist`
4. 设置环境变量：
   - `VITE_API_BASE_URL`: 后端API地址
   - `VITE_LLM_API_KEY`: LLM API密钥

#### 方法2: 手动部署
```bash
# 构建前端
cd frontend
npm run build

# 上传dist目录到Netlify
# 或使用Netlify CLI
npm install -g netlify-cli
netlify deploy --prod --dir=dist
```

## 后端API部署

### 1. Heroku部署

#### 创建Procfile
```bash
# backend/Procfile
web: uvicorn main:app --host 0.0.0.0 --port $PORT
```

#### 创建runtime.txt
```bash
# backend/runtime.txt
python-3.9.16
```

#### 部署步骤
```bash
# 安装Heroku CLI
# 登录Heroku
heroku login

# 创建应用
heroku create your-app-name

# 设置环境变量
heroku config:set HOST=0.0.0.0
heroku config:set PORT=8000
heroku config:set DEBUG=False

# 部署
git push heroku main
```

### 2. Railway部署

#### 创建railway.json
```json
{
  "build": {
    "builder": "NIXPACKS"
  },
  "deploy": {
    "startCommand": "uvicorn main:app --host 0.0.0.0 --port $PORT",
    "healthcheckPath": "/health"
  }
}
```

#### 部署步骤
1. 连接GitHub仓库到Railway
2. 配置环境变量
3. 自动部署

### 3. AWS部署

#### 使用Elastic Beanstalk
```bash
# 安装EB CLI
pip install awsebcli

# 初始化
eb init

# 创建环境
eb create production

# 部署
eb deploy
```

## 环境变量配置

### 开发环境
```bash
# .env.development
DEBUG=True
LOG_LEVEL=DEBUG
API_BASE_URL=http://localhost:8000
```

### 生产环境
```bash
# .env.production
DEBUG=False
LOG_LEVEL=INFO
API_BASE_URL=https://your-api-domain.com
REDIS_URL=redis://your-redis-host:6379
```

### Netlify环境变量
```bash
# 在Netlify控制台设置
VITE_API_BASE_URL=https://your-backend-api.herokuapp.com
VITE_LLM_API_KEY=your-llm-api-key
VITE_ENVIRONMENT=production
```

## 监控和日志

### 1. 应用监控

#### 健康检查端点
```python
# backend/main.py
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "version": "1.0.0"
    }
```

#### 性能监控
```python
# 添加性能监控
import time
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"Function {func.__name__} completed in {duration:.2f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"Function {func.__name__} failed after {duration:.2f}s: {str(e)}")
            raise
    return wrapper
```

### 2. 日志配置

#### 生产环境日志
```python
# backend/utils/logger.py
import logging
from logging.handlers import RotatingFileHandler

def setup_production_logging():
    # 文件日志
    file_handler = RotatingFileHandler(
        'logs/app.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setLevel(logging.INFO)
    
    # 控制台日志
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.WARNING)
    
    # 格式化
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # 配置根日志器
    logging.basicConfig(
        level=logging.INFO,
        handlers=[file_handler, console_handler]
    )
```

## 故障排除

### 1. 常见问题

#### 端口冲突
```bash
# 检查端口占用
netstat -tulpn | grep :8000
# 或
lsof -i :8000

# 杀死进程
kill -9 <PID>
```

#### 依赖问题
```bash
# 清理pip缓存
pip cache purge

# 重新安装依赖
pip install --no-cache-dir -r requirements.txt
```

#### 权限问题
```bash
# 修改文件权限
chmod +x scripts/*.sh
chown -R www-data:www-data /var/www/paper-search
```

### 2. 日志分析

#### 查看应用日志
```bash
# 查看实时日志
tail -f logs/app.log

# 查看错误日志
grep ERROR logs/app.log

# 查看访问日志
tail -f /var/log/nginx/access.log
```

#### 性能分析
```bash
# 查看系统资源
htop
# 或
top

# 查看内存使用
free -h

# 查看磁盘使用
df -h
```

## 安全配置

### 1. HTTPS配置

#### Nginx SSL配置
```nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /path/to/certificate.crt;
    ssl_certificate_key /path/to/private.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # 其他配置...
}
```

### 2. 防火墙配置

#### UFW配置
```bash
# 启用防火墙
sudo ufw enable

# 允许SSH
sudo ufw allow ssh

# 允许HTTP和HTTPS
sudo ufw allow 80
sudo ufw allow 443

# 允许应用端口
sudo ufw allow 8000
```

### 3. API安全

#### 限流配置
```python
# 添加API限流
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@app.post("/api/search/")
@limiter.limit("10/minute")
async def search_papers(request: Request, ...):
    pass
```

## 备份和恢复

### 1. 数据备份

#### 自动备份脚本
```bash
#!/bin/bash
# backup.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
APP_DIR="/var/www/paper-search"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份应用数据
tar -czf $BACKUP_DIR/app_$DATE.tar.gz -C $APP_DIR data logs

# 备份数据库
redis-cli --rdb $BACKUP_DIR/redis_$DATE.rdb

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete
find $BACKUP_DIR -name "*.rdb" -mtime +7 -delete
```

#### 定时任务
```bash
# 添加到crontab
crontab -e

# 每天凌晨2点备份
0 2 * * * /path/to/backup.sh
```

### 2. 数据恢复

#### 恢复应用数据
```bash
# 停止服务
sudo systemctl stop paper-search

# 恢复数据
tar -xzf /backups/app_20240101_020000.tar.gz -C /var/www/paper-search/

# 重启服务
sudo systemctl start paper-search
```

#### 恢复Redis数据
```bash
# 停止Redis
sudo systemctl stop redis

# 恢复数据
cp /backups/redis_20240101_020000.rdb /var/lib/redis/dump.rdb

# 启动Redis
sudo systemctl start redis
```

## 总结

通过本部署指南，您可以成功部署论文搜索引擎系统到各种环境。建议按照以下顺序进行部署：

1. **开发环境**: 本地开发和测试
2. **测试环境**: 模拟生产环境测试
3. **生产环境**: 正式部署和运行
4. **监控配置**: 设置监控和日志
5. **安全加固**: 配置安全措施
6. **备份策略**: 建立备份和恢复机制

记住定期更新依赖包、监控系统性能，并根据实际需求调整配置。
